"use client";

import React, { createContext, useContext, useState, useCallback, useEffect } from "react";
import { v4 as uuidv4 } from "uuid";
import { uploadToGooglePhotos } from "@/lib/googlePhotos";

export interface Generation {
  id: string;
  status: "queued" | "processing" | "completed" | "failed";
  imageUrl?: string;
  file?: File; // Store the file object for download/further processing
  prompt?: string;
  model?: string;
  error?: string;
  createdAt: number;
}

export interface Session {
  id: string;
  originalImage: File;
  currentImage: File;
  thumbnailUrl: string;
  status: "idle" | "processing" | "completed" | "error";
  statusMessage?: string;
  generations: Generation[];
  createdAt: number;
}

interface SessionContextType {
  sessions: Session[];
  activeSessionId: string | null;
  activeSession: Session | undefined;
  addSession: (file: File) => void;
  setActiveSessionId: (id: string | null) => void;
  updateSessionImage: (id: string, file: File, metadata?: { prompt?: string; model?: string }) => void;
  updateSessionStatus: (id: string, status: Session["status"], message?: string) => void;
  addGeneration: (sessionId: string, generation: Generation) => void;
  updateGeneration: (sessionId: string, generationId: string, updates: Partial<Generation>) => void;
  removeSession: (id: string) => void;
}

const SessionContext = createContext<SessionContextType | undefined>(undefined);

export function SessionProvider({ children }: { children: React.ReactNode }) {
  const [sessions, setSessions] = useState<Session[]>([]);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);

  const addSession = useCallback((file: File) => {
    const newSession: Session = {
      id: uuidv4(),
      originalImage: file,
      currentImage: file,
      thumbnailUrl: URL.createObjectURL(file),
      status: "idle",
      generations: [],
      createdAt: Date.now(),
    };
    setSessions((prev) => [newSession, ...prev]);
    setActiveSessionId(newSession.id);
  }, []);

  const updateSessionImage = useCallback((id: string, file: File, metadata?: { prompt?: string; model?: string }) => {
    setSessions((prev) =>
      prev.map((s) =>
        s.id === id
          ? { ...s, currentImage: file, thumbnailUrl: URL.createObjectURL(file), status: "completed", statusMessage: "Done!" }
          : s
      )
    );

    // Construct description for Google Photos
    let description = "Generated by Flux Web";
    if (metadata) {
      if (metadata.prompt) description += `\n\nPrompt: ${metadata.prompt}`;
      if (metadata.model) description += `\nModel: ${metadata.model}`;
    }

    // Attempt to upload to Google Photos if connected
    uploadToGooglePhotos(file, description)
      .then(() => console.log("Uploaded to Google Photos"))
      .catch((err) => {
        // Ignore "not connected" errors to avoid noise for non-connected users
        if (err.message !== "Google Photos not connected") {
          console.error("Failed to upload to Google Photos:", err);
        }
      });
  }, []);

  const updateSessionStatus = useCallback((id: string, status: Session["status"], message?: string) => {
    setSessions((prev) =>
      prev.map((s) => (s.id === id ? { ...s, status, statusMessage: message } : s))
    );
  }, []);

  const addGeneration = useCallback((sessionId: string, generation: Generation) => {
    setSessions((prev) =>
      prev.map((s) =>
        s.id === sessionId
          ? { ...s, generations: [generation, ...s.generations] }
          : s
      )
    );
  }, []);

  const updateGeneration = useCallback((sessionId: string, generationId: string, updates: Partial<Generation>) => {
    setSessions((prev) =>
      prev.map((s) => {
        if (s.id !== sessionId) return s;
        return {
          ...s,
          generations: s.generations.map((g) =>
            g.id === generationId ? { ...g, ...updates } : g
          ),
        };
      })
    );
  }, []);

  const removeSession = useCallback((id: string) => {
    setSessions((prev) => prev.filter((s) => s.id !== id));
    if (activeSessionId === id) {
      setActiveSessionId(null);
    }
  }, [activeSessionId]);

  const activeSession = sessions.find((s) => s.id === activeSessionId);

  return (
    <SessionContext.Provider
      value={{
        sessions,
        activeSessionId,
        activeSession,
        addSession,
        setActiveSessionId,
        updateSessionImage,
        updateSessionStatus,
        addGeneration,
        updateGeneration,
        removeSession,
      }}
    >
      {children}
    </SessionContext.Provider>
  );
}

export function useSession() {
  const context = useContext(SessionContext);
  if (!context) {
    throw new Error("useSession must be used within a SessionProvider");
  }
  return context;
}
